name: Submit New Files to Gravity Forms

on:
  push:
    paths-ignore:
      - '.github/workflows/**'
  create:
  workflow_dispatch:

jobs:
  submit_new_files:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository # (with full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Ensures full commit history is available

      - name: Detect new files (exclude renames) and submit to Gravity Forms
        env:
          GF_WEBHOOK_URL: ${{ secrets.GF_WEBHOOK_URL }}
          GITHUB_REPO: ${{ github.repository }}
          GITHUB_BRANCH: ${{ github.ref_name }}
          GITHUB_SHA: ${{ github.sha }}
        run: |
          set -euo pipefail
          # Ensure the previous commit exists
          BEFORE_COMMIT=${{ github.event.before }}
          if [ -z "$BEFORE_COMMIT" ] || ! git rev-parse "$BEFORE_COMMIT" >/dev/null 2>&1; then
            echo "Previous commit not found, using HEAD~1"
            BEFORE_COMMIT="HEAD~1"
          fi

          # Get added files, but exclude any that are part of a rename
          # Strategy:
          # 1) Collect added files (A)
          # 2) Collect renamed pairs (R) and extract the new path (right side)
          # 3) Subtract renamed-new-paths from added list
          ADDED_FILES=$(git -c core.quotepath=false diff -M --name-only --diff-filter=A "$BEFORE_COMMIT".."${{ github.sha }}")
          RENAMED_NEW_PATHS=$(git -c core.quotepath=false diff -M --name-status --diff-filter=R "$BEFORE_COMMIT".."${{ github.sha }}" | awk '{print $3}')
          # Filter ADDED_FILES to remove any path that appears as a renamed destination
          CLEAN_ADDED_FILES=""
          if [ -n "$ADDED_FILES" ]; then
            while IFS= read -r FILE; do
              [ -z "$FILE" ] && continue
              if ! echo "$RENAMED_NEW_PATHS" | grep -Fxq "$FILE"; then
                CLEAN_ADDED_FILES="${CLEAN_ADDED_FILES}"$'\n'"$FILE"
              fi
            done <<< "$ADDED_FILES"
            CLEAN_ADDED_FILES=$(echo "$CLEAN_ADDED_FILES" | sed '/^$/d')
          fi

          if [ -n "$CLEAN_ADDED_FILES" ]; then
            echo "New files detected (renames excluded):"
            echo "$CLEAN_ADDED_FILES"

            echo "$CLEAN_ADDED_FILES" | while IFS= read -r FILE; do
              [ -z "$FILE" ] && continue
              FILE_NAME=$(basename "$FILE")
              FILE_NAME=${FILE_NAME%.*}
              ENCODED_FILE_NAME=$(echo "$FILE" | jq -sRr @uri) # encode full path for URLs

              BLOB_URL="https://github.com/${GITHUB_REPO}/blob/${GITHUB_SHA}/${ENCODED_FILE_NAME}"
              RAW_URL="https://raw.githubusercontent.com/${GITHUB_REPO}/${GITHUB_BRANCH}/${ENCODED_FILE_NAME}"

              JSON_PAYLOAD=$(jq -n \
                --arg file_name "$FILE_NAME" \
                --arg blob_url "$BLOB_URL" \
                --arg raw_url "$RAW_URL" \
                '{input_1: $file_name, input_5: $blob_url, input_4: $raw_url}')

              echo "Submitting data for: $FILE_NAME"
              echo "Blob URL: $BLOB_URL"
              echo "Raw URL: $RAW_URL"

              HTTP_STATUS=$(curl -sS -o /tmp/resp.json -w "%{http_code}" -X POST "$GF_WEBHOOK_URL" \
                -u "${{ secrets.GF_CONSUMER_KEY }}:${{ secrets.GF_CONSUMER_SECRET }}" \
                -H "Content-Type: application/json" \
                -d "$JSON_PAYLOAD")

              if [ "$HTTP_STATUS" -lt 200 ] || [ "$HTTP_STATUS" -ge 300 ]; then
                echo "⚠️ Webhook failed for $FILE_NAME (HTTP $HTTP_STATUS):"
                cat /tmp/resp.json 2>/dev/null || echo "(no response body)"
                exit 1
              else
                echo "✓ Success (HTTP $HTTP_STATUS)"
          
                # Extract entry_id from the saved response
                ENTRY_ID=$(jq -r '.entry_id // empty' /tmp/resp.json)

                if [ -n "$ENTRY_ID" ]; then
                  echo "Captured Entry ID: $ENTRY_ID"
          
                  # Sanitize filename: lowercase, spaces to dashes, remove specific chars (& , ' " ( ))
                  SANITIZED_NAME=$(echo "$FILE_NAME" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | tr -d "&,'\"()")
          
                  # Construct the URL for field 10
                  FIELD_10_VALUE="https://brightleafdigital.io/code/entry/${ENTRY_ID}-${SANITIZED_NAME}"
          
                  echo "Updating Field 10 with: $FIELD_10_VALUE"
          
                  # Create payload for field 10 update
                  UPDATE_PAYLOAD=$(jq -n --arg val "$FIELD_10_VALUE" '{ "10": $val }')
          
                  # Send PUT request to update the entry
                  UPDATE_STATUS=$(curl -sS -o /dev/null -w "%{http_code}" -X PUT "https://brightleafdigital.io/wp-json/gf/v2/entries/${ENTRY_ID}" \
                    -u "${{ secrets.GF_CONSUMER_KEY }}:${{ secrets.GF_CONSUMER_SECRET }}" \
                    -H "Content-Type: application/json" \
                    -d "$UPDATE_PAYLOAD")
          
                  if [ "$UPDATE_STATUS" -lt 200 ] || [ "$UPDATE_STATUS" -ge 300 ]; then
                    echo "⚠️ Update failed (HTTP $UPDATE_STATUS)"
                    exit 1
                  else
                    echo "✓ Entry updated successfully"
                  fi
                fi
              fi
            done
          else
            echo "No new files detected (renames excluded)."
          fi